use std::{ffi::c_void, ops::Range};

use anyhow::{Context, Result};
use bit_field::BitField;
use bytemuck::{bytes_of, bytes_of_mut, AnyBitPattern, NoUninit};
use nix::{
    libc::{user_regs_struct, SYS_mmap, MAP_ANONYMOUS, MAP_PRIVATE, PROT_READ, PROT_WRITE},
    sys::{ptrace, wait},
    unistd::Pid,
};
use tracing::{error, info, trace};

pub struct Tracee {
    pid: Option<Pid>,
}

impl Tracee {
    /// Attach to a process.
    pub fn attach(pid: Pid) -> Result<Self> {
        info!(%pid, "Attaching to process");
        ptrace::attach(pid).context("failed to attach to process")?;
        wait::waitpid(pid, None).context("failed to wait for attach to be done")?;
        Ok(Self { pid: Some(pid) })
    }

    /// Return the process identifier of the tracee.
    pub fn pid(&self) -> Pid {
        self.pid.unwrap()
    }

    /// Resolve the path of the executable.
    pub fn find_exe_path(&self) -> Result<String> {
        let pid = self.pid();
        let path = format!("/proc/{pid}/exe");
        let path_buf = std::fs::read_link(path).context("failed to resolve exe link")?;
        let path = path_buf.to_str().context("exe path is not valid utf8")?;
        Ok(path.to_string())
    }

    /// Find all addresses that are mappped to a given file.
    pub fn find_mapped_addresses(&self, file: &str) -> Result<Vec<Range<u64>>> {
        let pid = self.pid();
        let path = format!("/proc/{pid}/maps");
        let maps =
            std::fs::read_to_string(&path).context("failed to resolve proccess memory map")?;

        Ok(maps
            .lines()
            .filter(|line| !line.contains("---p"))
            .filter(|line| line.ends_with(file))
            .map(|line| {
                let (start_addr, rest) = line.split_once('-').unwrap();
                let (end_addr, _) = rest.split_once(' ').unwrap();
                let start_addr = u64::from_str_radix(start_addr, 16).unwrap();
                assert_eq!(start_addr & 0xFFF, 0);
                let end_addr = u64::from_str_radix(end_addr, 16).unwrap();
                assert_eq!(end_addr & 0xFFF, 0);
                start_addr..end_addr
            })
            .collect())
    }

    /// Find the first address that is mapped to a given file.
    pub fn find_base_address(&self, file: &str) -> Result<u64> {
        let pid = self.pid();
        let path = format!("/proc/{pid}/maps");
        let maps =
            std::fs::read_to_string(&path).context("failed to resolve proccess memory map")?;

        let first_line = maps
            .lines()
            .find(|line| line.ends_with(file))
            .with_context(|| format!("{file:?} not mapped"))?;

        let (start_addr, _) = first_line.split_once('-').unwrap();
        let start_addr = u64::from_str_radix(start_addr, 16).unwrap();
        assert_eq!(start_addr & 0xFFF, 0);
        Ok(start_addr)
    }

    /// Peek the general purpose registers.
    pub fn peek_registers(&self) -> Result<user_regs_struct> {
        let pid = self.pid();
        ptrace::getregs(pid).context("failed to peek registers")
    }

    /// Poke the general purpose registers.
    pub fn poke_registers(&self, regs: user_regs_struct) -> Result<()> {
        let pid = self.pid();
        ptrace::setregs(pid, regs).context("failed to peek registers")
    }

    /// Read from the process's memory.
    pub fn peek_memory<T>(&self, mut address: u64, data: &mut T) -> Result<()>
    where
        T: NoUninit + AnyBitPattern,
    {
        let pid = self.pid();
        let data = bytes_of_mut(data);
        data.chunks_mut(8).try_for_each(|chunk| {
            let value = ptrace::read(pid, address as *mut c_void)
                .context("failed to read process memory")?;
            trace!(address, value, "Read memory");
            let bytes = value.to_ne_bytes();
            chunk.copy_from_slice(&bytes[..chunk.len()]);
            address += chunk.len() as u64;
            Ok(())
        })
    }

    /// Write to the process's memory.
    pub fn poke_memory<T>(&self, mut address: u64, data: &T) -> Result<()>
    where
        T: NoUninit + AnyBitPattern,
    {
        let pid = self.pid();
        let data = bytes_of(data);
        data.chunks(8).try_for_each(|chunk| {
            let value = ptrace::read(pid, address as *mut c_void)
                .context("failed to read process memory")?;
            trace!(address, value, "Read memory");
            let mut bytes = value.to_ne_bytes();
            bytes[..chunk.len()].copy_from_slice(chunk);

            let value = u64::from_ne_bytes(bytes);
            unsafe {
                ptrace::write(pid, address as *mut c_void, value as *mut c_void)?;
            }

            address += chunk.len() as u64;
            Ok(())
        })
    }

    const DEBUG_REGISTERS_OFFSET: usize = 0x350;

    /// Peek the debug registers.
    pub fn peek_debug_registers(&self) -> [u64; 8] {
        let mut debug_registers = [0; 8];

        let pid = self.pid();

        for (i, debug_register) in debug_registers.iter_mut().enumerate() {
            unsafe {
                *debug_register = nix::libc::ptrace(
                    nix::libc::PTRACE_PEEKUSER,
                    pid,
                    Self::DEBUG_REGISTERS_OFFSET + i * 8,
                    0,
                ) as u64;
            }
        }

        trace!(?debug_registers, "Peeked debug registers");

        debug_registers
    }

    /// Poke the debug registers.
    pub fn poke_debug_registers(&self, debug_registers: [u64; 8]) {
        trace!(?debug_registers, "Poking debug registers");

        let pid = self.pid();

        for (i, debug_register) in debug_registers.into_iter().enumerate() {
            unsafe {
                nix::libc::ptrace(
                    nix::libc::PTRACE_POKEUSER,
                    pid,
                    Self::DEBUG_REGISTERS_OFFSET + i * 8,
                    debug_register,
                );
            }
        }
    }

    /// Remove all hardware breakpoints.
    pub fn clear_breakpoints(&mut self) {
        self.poke_debug_registers([0, 0, 0, 0, 0, 0, 4294905840, 0]);
    }

    /// Create a execute hardware breakpoint.
    pub fn create_breakpoint(&self, address: u64) -> Result<Breakpoint> {
        let mut debug_registers = self.peek_debug_registers();

        let idx = (0..4)
            .find(|i| !debug_registers[7].get_bit(*i * 2))
            .context("all breakpoints are in use")?;

        // Enable the breakpoint globally.
        debug_registers[7].set_bit(idx * 2, true);
        // Only catch instruction fetches.
        debug_registers[7].set_bits(16 + idx * 4..18 + idx * 4, 0);
        // Only catch access to the exact byte.
        debug_registers[7].set_bits(18 + idx * 4..20 + idx * 4, 0);

        debug_registers[idx] = address;

        self.poke_debug_registers(debug_registers);

        Ok(Breakpoint {
            index: idx as u8,
            tracee: self,
        })
    }

    /// Call `mmap` inside the tracee to allocate some memory.
    pub fn allocate_memory(&self, base_address: u64, size: u64) -> Result<u64> {
        let pid = self.pid();

        // Save the registers.
        let orig_registers = self.peek_registers()?;

        let mut new_registers = orig_registers;
        new_registers.rax = SYS_mmap as u64;
        new_registers.rip = base_address + 0x168468; // address of a syscall instruction
        new_registers.rdi = 0;
        new_registers.rsi = size;
        new_registers.rdx = (PROT_READ | PROT_WRITE) as u64;
        new_registers.r10 = (MAP_PRIVATE | MAP_ANONYMOUS) as u64;
        new_registers.r8 = 0;
        new_registers.r9 = 0;
        self.poke_registers(new_registers)?;
        trace!(?new_registers);

        ptrace::syscall(pid, None).context("failed to start syscall execution")?;
        wait::waitpid(pid, None).context("failed to wait for signal")?;
        ptrace::syscall(pid, None).context("failed to finish syscall execution")?;
        wait::waitpid(pid, None).context("failed to wait for signal")?;
        // Not sure why we need to step again...
        ptrace::step(pid, None).context("failed to finish syscall execution")?;
        wait::waitpid(pid, None).context("failed to wait for signal")?;

        let result_registers = self.peek_registers()?;
        trace!(?result_registers);
        let addr = result_registers.rax;
        trace!(?addr);

        // Restore the registers.
        self.poke_registers(orig_registers)?;
        let new_orig_registers = self.peek_registers()?;
        assert_eq!(new_orig_registers, orig_registers);

        Ok(addr)
    }

    /// Continue execution.
    pub fn r#continue(&self) -> Result<()> {
        let pid = self.pid();
        ptrace::cont(pid, None).context("failed to restart proccess")?;
        wait::waitpid(pid, None).context("failed to wait for signal")?;
        Ok(())
    }

    /// Run until `handler` intercepts a syscall.
    pub fn intercept_syscall(
        &self,
        mut handler: impl FnMut(user_regs_struct) -> Option<user_regs_struct>,
    ) -> Result<()> {
        let pid = self.pid();

        loop {
            ptrace::syscall(pid, None).context("failed to start syscall execution")?;
            wait::waitpid(pid, None).context("failed to wait for signal")?;

            let registers = self.peek_registers()?;
            if let Some(custom_registers) = handler(registers) {
                let mut new_registers = registers;
                new_registers.rax = 39; // getpid
                new_registers.orig_rax = 39; // getpid
                self.poke_registers(new_registers)
                    .context("failed to change the syscall to getpid")?;

                ptrace::syscall(pid, None).context("failed to end syscall execution")?;
                wait::waitpid(pid, None).context("failed to wait for signal")?;

                self.poke_registers(custom_registers)
                    .context("failed to replace the registers")?;
                return Ok(());
            } else {
                ptrace::syscall(pid, None).context("failed to end syscall execution")?;
                wait::waitpid(pid, None).context("failed to wait for signal")?;
            }
        }
    }

    /// Detach from the process.
    fn detach_by_ref(&mut self) -> Result<()> {
        if let Some(pid) = self.pid.take() {
            info!(%pid, "Detaching from process");
            ptrace::detach(pid, None).context("failed to detach from process")?;
        }
        Ok(())
    }
}

impl Drop for Tracee {
    fn drop(&mut self) {
        if let Err(err) = self.detach_by_ref() {
            error!(?err);
        }
    }
}

pub struct Breakpoint<'a> {
    index: u8,
    tracee: &'a Tracee,
}

impl Breakpoint<'_> {
    /// Returns  whether the breakpoint was just hit.
    pub fn was_hit(&self) -> bool {
        let mut debug_registers = self.tracee.peek_debug_registers();

        // Check if the breakpoint was hit.
        if !debug_registers[6].get_bit(self.index as usize) {
            // No, it wasn't.
            return false;
        }

        // Clear the flag.
        debug_registers[6].set_bit(self.index as usize, false);

        self.tracee.poke_debug_registers(debug_registers);

        true
    }
}

impl Drop for Breakpoint<'_> {
    fn drop(&mut self) {
        let mut debug_registers = self.tracee.peek_debug_registers();
        // Disable the breakpoint.
        debug_registers[7].set_bit(self.index as usize * 2, false);

        self.tracee.poke_debug_registers(debug_registers);
    }
}
